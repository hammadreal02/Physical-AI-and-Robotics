"use strict";(globalThis.webpackChunkdocusaurus_init_temp=globalThis.webpackChunkdocusaurus_init_temp||[]).push([[733],{8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var o=s(6540);const t={},i=o.createContext(t);function r(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),o.createElement(i.Provider,{value:n},e.children)}},8558:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"module-ros2/chapter-3","title":"ROS 2 Fundamentals: Week 3 - Services and Actions","description":"Building upon topics and messages, this week we explore two other crucial communication paradigms in ROS 2: Services and Actions. These mechanisms allow for more structured and complex interactions between nodes.","source":"@site/docs/01-module-ros2/chapter-3.md","sourceDirName":"01-module-ros2","slug":"/module-ros2/chapter-3","permalink":"/Physical-AI-and-robotic/docs/module-ros2/chapter-3","draft":false,"unlisted":false,"editUrl":"https://github.com/hammadreal02/Physical-AI-and-robotic/tree/main/docs/01-module-ros2/chapter-3.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"ROS 2 Fundamentals: Week 2 - Nodes, Topics, and Messages","permalink":"/Physical-AI-and-robotic/docs/module-ros2/chapter-2"},"next":{"title":"ROS 2 Fundamentals: Week 4 - Parameters, Launch Files, and Best Practices","permalink":"/Physical-AI-and-robotic/docs/module-ros2/chapter-4"}}');var t=s(4848),i=s(8453);const r={sidebar_position:3},a="ROS 2 Fundamentals: Week 3 - Services and Actions",c={},l=[{value:"ROS 2 Services: Synchronous Request/Reply",id:"ros-2-services-synchronous-requestreply",level:2},{value:"ROS 2 Actions: Asynchronous, Long-running Tasks",id:"ros-2-actions-asynchronous-long-running-tasks",level:2},{value:"Hands-on: Implementing a Simple ROS 2 Service and Action",id:"hands-on-implementing-a-simple-ros-2-service-and-action",level:2}];function d(e){const n={h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"ros-2-fundamentals-week-3---services-and-actions",children:"ROS 2 Fundamentals: Week 3 - Services and Actions"})}),"\n",(0,t.jsx)(n.p,{children:"Building upon topics and messages, this week we explore two other crucial communication paradigms in ROS 2: Services and Actions. These mechanisms allow for more structured and complex interactions between nodes."}),"\n",(0,t.jsx)(n.h2,{id:"ros-2-services-synchronous-requestreply",children:"ROS 2 Services: Synchronous Request/Reply"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Services"})," in ROS 2 provide a synchronous request/reply mechanism. This is useful when you need a node to perform a specific task and return a result immediately. Think of it like a function call in a distributed system."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Service Server"}),": A node that offers a service. It waits for incoming requests, performs the computation, and sends back a response."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Service Client"}),": A node that calls a service. It sends a request and blocks (or waits asynchronously) until it receives a response."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"ros-2-actions-asynchronous-long-running-tasks",children:"ROS 2 Actions: Asynchronous, Long-running Tasks"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Actions"}),' are designed for long-running tasks that provide periodic feedback and can be preempted. They are built on top of topics and services and provide a more robust way to handle complex behaviors like "move to a goal" or "pick up object."']}),"\n",(0,t.jsx)(n.p,{children:"An action consists of three parts:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Goal"}),": The target of the action (e.g., target pose for navigation)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Result"}),": The outcome of the action (e.g., success/failure, final pose)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Feedback"}),": Intermediate updates during the execution of the action (e.g., current pose, remaining distance)."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"hands-on-implementing-a-simple-ros-2-service-and-action",children:"Hands-on: Implementing a Simple ROS 2 Service and Action"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Service Example"}),": Create a service that takes two integers as input and returns their sum. Implement both a server node and a client node."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Action Example"}),": Develop a simple action that counts from 1 to N, providing feedback on the current count and allowing the client to cancel the counting process."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These examples will demonstrate when to choose services over topics, and actions over services, based on the communication requirements of your robot's tasks."})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);